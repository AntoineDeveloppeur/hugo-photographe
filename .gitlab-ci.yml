stages:
  - test
  - build-backend
  - build-frontend
  #- deployToVPS

# Cache des dépendances pour accélérer les jobs
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .next/cache/
    - backend/node_modules/

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

services:
  - docker:dind

before_script:
  - docker info
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER
    --password-stdin $CI_REGISTRY

unit-tests:
  stage: test
  image: node:20-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run test
  artifacts:
    reports:
      junit: junit.xml
    when: always
  allow_failure: true

lint:
  stage: test
  image: node:20-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run lint
  allow_failure: true

typescript:
  stage: test
  image: node:20-alpine
  script:
    - npm ci --legacy-peer-deps
    - cd ./backend && npm ci
    - npm run type-check

build-backend:
  stage: build-backend
  image: docker:latest
  before_script:
    # Créer le fichier .env à partir des variables CI/CD
    - |
      cat > ./backend/.env << EOF
      NODE_ENV=$NODE_ENV
      RECAPTCHA_SECRET_KEY=$RECAPTCHA_SECRET_KEY
      HUGO_EMAIL=$HUGO_EMAIL
      HUGO_PHONE=$HUGO_PHONE
      SERVER_PORT=$SERVER_PORT
      SECRET_PHRASE_TOKEN=$SECRET_PHRASE_TOKEN
      AWS_REGION=$AWS_REGION
      AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
      AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
      AWS_S3_BUCKET_NAME=$AWS_S3_BUCKET_NAME
      DB_USERNAME=$DB_USERNAME
      DB_PASSWORD=$DB_PASSWORD
      DB_CLUSTER=$DB_CLUSTER
      DB_NAME=$DB_NAME
      DB_APPNAME=$DB_APPNAME
      EOF
    - echo ./backend/.env
    # Se connecter a gitlab registry
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
      $CI_REGISTRY
  script:
    - echo "${CI_REGISTRY_IMAGE}/backend:latest"
    - docker-compose -f docker-compose.ci.yml build backend
    - docker-compose -f docker-compose.ci.yml push backend
    # Enregistre un backup avec la réf du commit
    - docker tag ${CI_REGISTRY_IMAGE}/backend:latest
      ${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHA}
    - docker push ${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHA}

build-frontend:
  image: docker:latest
  stage: build-frontend
  before_script:
    - echo
    # Run l'image backend nécessaire pour que le Front fetch les données pour le SSG
    - docker-compose -f docker-compose.ci.yml up -d backend
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
      $CI_REGISTRY
  script:
    - docker-compose -f docker-compose.ci.yml build frontend
    - docker-compose -f docker-compose.ci.yml push frontend
    # Enregistre un backup avec la réf du commit
    - docker tag ${CI_REGISTRY_IMAGE}/frontend:latest
      ${CI_REGISTRY_IMAGE}/frontend:${CI_COMMIT_SHA}
    - docker push "$CI_REGISTRY_IMAGE/frontend:${CI_COMMIT_SHA}"
# Nécessaire pour construire une application Next.js avec SSG

#deploy-docker-images:
#  image: ubuntu:latest
# stage: deployToVPS
#only:
#  - main
#before_script:
# - apt-get -yq update
#- apt-get -yqq install ssh
#- install -m 600 -D /dev/null ~/.ssh/id_rsa
#- echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
#- ssh-keyscan -H $SSH_HOST > ~/.ssh/known_hosts
# script:
#   - ssh $SSH_USER@$SSH_HOST "cd $WORK_DIR && docker compose pull && docker
#     compose -f docker-compose.prod.yml up -d backend && docker compose -f
#     docker-compose.prod.yml up -d frontend && exit"
# after_script:
#   - rm -rf ~/.ssh
